import socket
import threading
import sys
from colorama import init, Fore, Back, Style
import random
import uuid
from Crypto.Util.number import long_to_bytes

# Configuration du serveur
host = "0.0.0.0"
port = 1234
global connected
connected = True

# Fonction pour envoyer des messages
def send(socket, host):
    global connected
    hostup = True
    while hostup:
        try:
            msg = input(f"server@{host} $:")
            print("\033[1A\033[2K", end="")  # up + clear line
            print(f"you: {msg}") if msg else None
            socket.send(msg.encode()) if msg else None
        except ConnectionResetError:
            hostup = False
            socket.close()
            print("La connexion a été interrompue par le client")
            break
        except OSError:  # quand le socket est fermé
            break
        else:
            if msg == "arret":
                connected = False
                break
            msg = None
    socket.close()

# Fonction pour recevoir des messages
def receive(socket, host):
    global hostup
    global connected
    hostup = True
    while hostup:
        try:
            reply = socket.recv(1024).decode()
        except ConnectionResetError:
            hostup = False
            print("La connexion a été interrompue par le client")
            break
        except ConnectionAbortedError:
            hostup = False
            print("Le serveur a fermé sa connexion")
            socket.close()
            break
        else:
            print("\033[2K", end="\r")  # carriage return + clear line
            print(f"client: {reply}")
            print('\033[1F', f'\nyou@{host} $:', end="") if reply else None
            if reply == "arret":
                connected = False
                break
            reply = None
    socket.close()

# Fonction pour l'interaction avec le client
def interactive(target, host):
    uniqueid = uuid.UUID(int=random.getrandbits(128))
    globals()[f"{str(uniqueid)}"] = True
    global connected
    connected = True
    print("Connected to client")
    threading.Thread(target=receive, args=(target, host)).start()
    send(target, host)
    target.close()
    return 0

# Création du socket serveur
server_socket = socket.socket()
server_socket.bind((host, port))
server_socket.listen(5)

# Boucle principale d'attente de connexions
while connected:
    conn, address = server_socket.accept()
    message = conn.recv(1024).decode()
    client_challenge = message.split(",")
    connect_condition = lambda x: int(x) % 2 == 0
    client_condition = all(connect_condition(elem) for elem in client_challenge)
    if client_condition:
        conn.send("synced".encode())
        threading.Thread(target=interactive, args=(conn, host)).start()
        conn.close() if not connected else None
    else:
        conn.send("garbage".encode())
        conn.close()
